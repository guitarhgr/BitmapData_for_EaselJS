<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../src/bitmapdata-1.0.0.js - BitmapData for EaselJS</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="BitmapData for EaselJS"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/createjs.BitmapData.html">createjs.BitmapData</a></li>
            
                <li><a href="../classes/createjs.BitmapDataChannel.html">createjs.BitmapDataChannel</a></li>
            
                <li><a href="../classes/createjs.ColorTransform.html">createjs.ColorTransform</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ../src/bitmapdata-1.0.0.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
BitmapData for EaselJS
Version: 1.00
Author: kudox
http://kudox.jp/
http://twitter.com/u_kudox
Licensed under the MIT License
Copyright (c) 2013 kudox.jp
*/

/**
* @namespace createjs
**/
this.createjs = this.createjs || {};

(function(window) {
	&quot;use strict&quot;;

	/**
	* BitmapData for EaselJSは、EalseJSにActionScript3.0と同様のBitmapDataクラスを提供します。BitmapDataクラスはDisplayObjectを継承していないため、実際にStage上に表示するにはBitmapクラスを使います。この流れはFlashと同様ですが、BitmapクラスのコンストラクタにはBitmapDataインスタンスではなく、BitmapDataインスタンスのcanvasプロパティを渡して下さい。
	* @class BitmapData
	* @constructor
	* @param [image=null] {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} この引数を指定すると指定したオブジェクトが描画されたBitmapDataが作成されます。指定するオブジェクトは、読み込みが終わっている必要があります。塗りのBitmapDataを作成したい場合は、nullを指定して下さい。
	* @param [width=image.width] {uint} BitmapDataの幅です。imageがnullの場合のdefault値は300です。
	* @param [height=image.height] {uint} BitmapDataの高さです。imageがnullの場合のdefault値は150です。
	* @param [fillColor=undefined] {String | uint} 塗りのBitmapDataを作成する場合に指定します。CSS文字列と0xAARRGGBB形式の16進数値が使えます。透明なBitmapDataを作成したい場合は、この引数を省略して下さい。
	* @example
	* &lt;pre&gt;&lt;code&gt;_bmd01 = new createjs.BitmapData(HTMLImageElement);
_bitmap01 = new createjs.Bitmap(_bmd01.canvas);
_stage.addChild(_bitmap01);
var width = 200;
var height = 200;
var fillColor = 0x80FF0000;
_bmd02 = new createjs.BitmapData(null, width, height, fillColor);
_bitmap02 = new createjs.Bitmap(_bmd02.canvas);
_stage.addChild(_bitmap02);&lt;/code&gt;&lt;/pre&gt;
	**/
	function BitmapData(image, width, height, fillColor) {
		width = width &gt;&gt; 0 || image.width || 300;
		height = height &gt;&gt; 0 || image.height || 150;
		var cvs = this.canvas = createCanvas(width, height);
		var ctx = this.context = cvs.getContext(&quot;2d&quot;);
		if (!!image) ctx.drawImage(image, 0, 0);
		if (fillColor !== undefined) this.fillRect(new createjs.Rectangle(0, 0, width, height), fillColor);
		if (!this._imageData) this._imageData = ctx.getImageData(0, 0, width, height);
	}

	BitmapData.VERSION = &quot;1.0.0&quot;;

	/**
	* cache()されたDisplayObjectのサブクラスをBitmapDataとして取得します。このメソッドで得られるBitmapDataは、DisplayObjectのcacheの参照です。updateCache()を実行した場合は、取得したBitmapDataも更新されるため、updateImageData()を実行して下さい。
	* @static
	* @method getBitmapData
	* @param object {DisplayObject} BitmapDataとして取得したいDisplayObjectのサブクラスを指定します。DisplayObjectはcache()されている必要があります。
	* @return {BitmapData} DisplayObjectのcacheをBitmapDataとして返します。
	* @example
	* &lt;pre&gt;&lt;code&gt;_shape = new createjs.Shape();
var g = _shape.graphics;
g.f(&amp;quot;rgba(0, 0, 255, 1)&amp;quot;).dp(0, 0, 100, 5, 0.6, -90).ef();
_shape.cache(-100, -100, 200, 200);
_bmd01 = createjs.BitmapData.getBitmapData(_shape);
var colorTransform = new createjs.ColorTransform(1, 1, 0, 1, 255);
var rect = new createjs.Rectangle(0, 0, _bmd01.width &amp;gt;&amp;gt; 1, _bmd01.height);
_bmd01.colorTransform(rect, colorTransform);
_stage.addChild(_shape);&lt;/code&gt;&lt;/pre&gt;
	**/
	BitmapData.getBitmapData = function(object) {
		var bmd, cvs;
		if (object instanceof createjs.DisplayObject) {
			if (!!object.cacheCanvas) {
				bmd = Object.create(BitmapData.prototype);
				cvs = bmd.canvas = object.cacheCanvas;
			} else {
				throw new Error(&quot;The object must be called DisplayObject.cache().&quot;);
			}
		} else {
			return;
		}
		var ctx = bmd.context = cvs.getContext(&quot;2d&quot;);
		bmd._imageData = ctx.getImageData(0, 0, cvs.width, cvs.height);
		return bmd;
	};

	var p = BitmapData.prototype = {
		/**
		* [read only] BitmapDataの幅です。
		* @property width
		* @type uint
		* @readOnly
		**/
		get width() {
			return this.canvas.width;
		},

		/**
		* [read only] BitmapDataの高さです。
		* @property height
		* @type uint
		* @readOnly
		**/
		get height() {
			return this.canvas.height;
		},

		/**
		* [read only] BitmapDataの位置とサイズを示すRectangleです。
		* @property rect
		* @type Rectangle
		* @readOnly
		**/
		get rect() {
			return new createjs.Rectangle(0, 0, this.canvas.width, this.canvas.height);
		}
	};

	p.constructor = BitmapData;

	/**
	* BitmapDataが描画されるHTMLCanvasElementです。
	* @property canvas
	* @type HTMLCanvasElement
	**/
	p.canvas = null;

	/**
	* canvasのCanvasRenderingContext2Dです。
	* @property context
	* @type CanvasRenderingContext2D
	**/
	p.context = null;

	/**
	* BitmapDataの名前です。toString()で使用されます。
	* @property name
	* @type String
	* @default null
	**/
	p.name = null;

	p._imageData = null;
	p._contextChanged = false;

	/**
	* ソースオブジェクトにFilterを適用し、現在のBitmapDataに貼付けます。sourceには、現在のBitmapDataを指定することもできます。
	* @method applyFilter
	* @param source {BitmapData | DisplayObject | Stage | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} ソースとなるオブジェクトを指定します。
	* @param sourceRect {Rectangle} ソースオブジェクトの範囲を示すRectangleです。
	* @param destPoint {Point} Filterを適用したイメージが配置される左上の座標を示すPointです。
	* @param filter {Filter} 適用するFilterを指定します。
	* @example
	* &lt;pre&gt;&lt;code&gt;_bmd01 = new createjs.BitmapData(_image01);
var source = _bmd01;
var sourceRect = new createjs.Rectangle(90, 20, 200, 200);
var destPoint = new createjs.Point(90, 20);
var filter = new createjs.BlurFilter(8, 8, 1);
_bmd01.applyFilter(source, sourceRect, destPoint, filter);&lt;/code&gt;&lt;/pre&gt;
	**/
	p.applyFilter = function(source, sourceRect, destPoint, filter) {
		var sx = sourceRect.x &gt;&gt; 0;
		var sy = sourceRect.y &gt;&gt; 0;
		var sw = sourceRect.width &gt;&gt; 0;
		var sh = sourceRect.height &gt;&gt; 0;
		var dx = destPoint.x &gt;&gt; 0;
		var dy = destPoint.y &gt;&gt; 0;
		if (source instanceof BitmapData || source instanceof createjs.Stage) {
			source = source.canvas;
		} else if (source instanceof createjs.DisplayObject) {
			if (!!source.cacheCanvas) {
				source = source.cacheCanvas;
			} else {
				throw new Error(&quot;The source of BitmapData.applyFilter(), must be called DisplayObject.cache().&quot;);
			}
		}
		var cvs = createCanvas(sw, sh);
		var ctx = cvs.getContext(&quot;2d&quot;);
		ctx.drawImage(source, -sx, -sy);
		filter.applyFilter(ctx, 0, 0, sw, sh);
		this.context.drawImage(cvs, dx, dy);
		this._contextChanged = true;
	};

	/**
	* 指定された領域のピクセルを透明な黒にして消去します。
	* @method clearRect
	* @param x {Number} 消去する領域の左上x座標です。
	* @param y {Number} 消去する領域の左上y座標です。
	* @param width {Number} 消去する領域の幅です。
	* @param height {Number} 消去する領域の高さです。
	* @example
	* &lt;pre&gt;&lt;code&gt;var x = 50;
var y = 50;
var width = 100;
var height = 100;
_bmd01.clearRect(x, y, width, height);&lt;/code&gt;&lt;/pre&gt;
	**/
	p.clearRect = function(x, y, width, height) {
		this.context.clearRect(x, y, width, height);
		this._contextChanged = true;
	};

	/**
	* 現在のBitmapDataのクローンを作成します。
	* @method clone
	* @return {BitmapData} 現在のBitmapDataのクローンです。
	**/
	p.clone = function() {
		var bmd = Object.create(BitmapData.prototype);
		var w = this.canvas.width;
		var h = this.canvas.height;
		var cvs = bmd.canvas = createCanvas(w, h);
		var ctx = bmd.context = cvs.getContext(&quot;2d&quot;);
		if (this._contextChanged) this.updateImageData();
		ctx.putImageData(this._imageData, 0, 0);
		bmd._imageData = ctx.getImageData(0, 0, w, h);
		return bmd;
	};

	/**
	* ColorTransformオブジェクトを使用して、BitmapDataの特定領域のカラー値を調整します。
	* @method colorTransform
	* @param rect {Rectangle} ColorTransformを適用する領域を示すRectangleです。
	* @param colorTransform {ColorTransform} 適用するColorTransformオブジェクトです。
	* @example
	* &lt;pre&gt;&lt;code&gt;_bmd01 = new createjs.BitmapData(_image01);
var halfW = _image01.width &amp;gt;&amp;gt; 1;
var rect = new createjs.Rectangle(halfW, 0, halfW, _image01.height);
var colorTransform = new createjs.ColorTransform(0.5, 1.5, 1.5);
_bmd01.colorTransform(rect, colorTransform);&lt;/code&gt;&lt;/pre&gt;
	**/
	p.colorTransform = function(rect, colorTransform) {
		var x = rect.x &gt;&gt; 0;
		var y = rect.y &gt;&gt; 0;
		var w = rect.width &gt;&gt; 0;
		var h = rect.height &gt;&gt; 0;
		var ctx = this.context;
		var imgData = ctx.getImageData(x, y, w, h);
		var data = imgData.data;
		for (var i = 0, l = data.length; i &lt; l; i += 4) {
			var r = i;
			var g = i + 1;
			var b = i + 2;
			var a = i + 3;
			data[r] = data[r] * colorTransform.redMultiplier + colorTransform.redOffset;
			data[g] = data[g] * colorTransform.greenMultiplier + colorTransform.greenOffset;
			data[b] = data[b] * colorTransform.blueMultiplier + colorTransform.blueOffset;
			data[a] = data[a] * colorTransform.alphaMultiplier + colorTransform.alphaOffset;
		}
		ctx.putImageData(imgData, x, y);
		this._contextChanged = true;
	};

	/**
	* 現在のBitmapDataと引数のオブジェクトのピクセルを比較し、その差分ピクセルを持つ新しいBitmapDataを返します。
	* @method compare
	* @param otherSource {BitmapData | DisplayObject | Stage | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} 比較に使用するオブジェクトです。
	* @return {BitmapData | int} 2つのオブジェクトの幅と高さが等しければ、2つのオブジェクトの差分ピクセルを持つ新しいBitmapDataを返します。&lt;br&gt;幅と高さ、及びすべてのピクセルが等しい場合、数値 0 を返します。&lt;br&gt;幅が等しくない場合、数値 -3 を返します。&lt;br&gt;幅が等しく、高さが等しくない場合、数値 -4 を返します。
	* @example
	* &lt;pre&gt;&lt;code&gt;_bmd01 = new createjs.BitmapData(_image01);
_bmd03 = new createjs.BitmapData(_image02);
var otherSource = _bmd03;
_bmd02 = _bmd01.compare(otherSource);
_bitmap01 = new createjs.Bitmap(_bmd01.canvas);
_bitmap02 = new createjs.Bitmap(_bmd02.canvas);
_bitmap03 = new createjs.Bitmap(_bmd03.canvas);
_bitmap01.x = 10;
_bitmap02.x = 220;
_bitmap03.x = 430;
_bitmap01.y = _bitmap02.y = _bitmap03.y = 80;&lt;/code&gt;&lt;/pre&gt;
	**/
	p.compare = function(otherSource) {
		var w = otherSource.width;
		var h = otherSource.height;
		if (this.canvas.width !== w) {
			return -3;
		} else if (this.canvas.height !== h) {
			return -4;
		}
		var oContext = getSourceContext(otherSource, w, h);
		var oImgData = oContext.getImageData(0, 0, w, h);
		var oData = oImgData.data;
		if (this._contextChanged) this.updateImageData();
		var cImgData = this._imageData;
		var cData = cImgData.data;
		if (Array.prototype.slice.call(cData).toString() === Array.prototype.slice.call(oData).toString()) {
			return 0;
		}
		var dBmd = Object.create(BitmapData.prototype);
		var dCanvas = dBmd.canvas = createCanvas(w, h);
		var dContext = dBmd.context = dCanvas.getContext(&quot;2d&quot;);
		var dImgData = dBmd._imageData = dContext.createImageData(w, h);
		var dData = dImgData.data;
		for (var i = 0, l = cData.length; i &lt; l; i += 4) {
			var r = i;
			var g = i + 1;
			var b = i + 2;
			var a = i + 3;
			var colorCompare = (cData[r] === oData[r]) &amp;&amp; (cData[g] === oData[g]) &amp;&amp; (cData[b] === oData[b]);
			var alphaCompare = cData[a] === oData[a];
			if (!colorCompare) {
				dData[r] = (cData[r] - oData[r]) &amp; 0xFF;
				dData[g] = (cData[g] - oData[g]) &amp; 0xFF;
				dData[b] = (cData[b] - oData[b]) &amp; 0xFF;
				dData[a] = 255;
			} else if (!alphaCompare) {
				dData[r] = dData[g] = dData[b] = 255;
				dData[a] = cData[a] - oData[a];
			}
		}
		dContext.putImageData(dImgData, 0, 0);
		return dBmd;
	};

	/**
	* ソースオブジェクトの1つのチャンネルを現在のBitmapDataのチャンネルに転送します。
	* @method copyChannel
	* @param source {BitmapData | DisplayObject | Stage | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} ソースとなるオブジェクトを指定します。
	* @param sourceRect {Rectangle} ソースオブジェクトの範囲を示すRectangleです。
	* @param destPoint {Point} データが配置される左上の座標を示すPointです。
	* @param sourceChannel {uint} ソースオブジェクトのチャンネルを指定します。BitmapDataChannelクラスの定数が使用できます。
	* @param destChannel {uint} 転送先のチャンネルを指定します。BitmapDataChannelクラスの定数が使用できます。
	* @example
	* &lt;pre&gt;&lt;code&gt;_bmd01 = new createjs.BitmapData(_image01);
var source = _image02;
var sourceRect = new createjs.Rectangle(0, 0, _image02.width, _image02.height);
var destPoint = new createjs.Point();
var channel = Object.create(createjs.BitmapDataChannel);
var sourceChannel = channel.ALPHA;
var destChannel = channel.BLUE;
_bmd01.copyChannel(source, sourceRect, destPoint, sourceChannel, destChannel);&lt;/code&gt;&lt;/pre&gt;
	**/
	p.copyChannel = function(source, sourceRect, destPoint, sourceChannel, destChannel) {
		var sx = sourceRect.x &gt;&gt; 0;
		var sy = sourceRect.y &gt;&gt; 0;
		var sw = sourceRect.width &gt;&gt; 0;
		var sh = sourceRect.height &gt;&gt; 0;
		var dx = destPoint.x &gt;&gt; 0;
		var dy = destPoint.y &gt;&gt; 0;
		var sContext = getSourceContext(source, sx + sw, sy + sh);
		var sImgData = sContext.getImageData(sx, sy, sw, sh);
		var sData = sImgData.data;
		var sChannel = BitmapDataChannel.getChannelIndex(sourceChannel);
		var dContext = this.context;
		var dImgData = dContext.getImageData(dx, dy, sw, sh);
		var dData = dImgData.data;
		var dChannel = BitmapDataChannel.getChannelIndex(destChannel);
		for (var i = 0, l = dData.length; i &lt; l; i += 4) {
			dData[i + dChannel] = sData[i + sChannel];
		}
		dContext.putImageData(dImgData, dx, dy);
		this._contextChanged = true;
	};

	/**
	* ソースオブジェクトを現在のBitmapDataに貼り付けます。
	* @method copyPixels
	* @param source {BitmapData | DisplayObject | Stage | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} ソースとなるオブジェクトを指定します。
	* @param sourceRect {Rectangle} ソースオブジェクトの範囲を示すRectangleです。
	* @param destPoint {Point} 貼り付け先の左上座標を示すPointです。
	* @param [alphaSource=null] {BitmapData | DisplayObject | Stage | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} アルファチャンネルのソースとなるオブジェクトを指定します。
	* @param [alphaPoint=null] {Point} alphaSourceの左上座標を示すPointです。
	* @param [mergeAlpha=false] {Boolean} 貼り付け時にアルファチャンネルを使用するにはtrueを指定します。
	* @example
	* &lt;pre&gt;&lt;code&gt;_bmd01 = new createjs.BitmapData(null, 640, 360, 0xCCCCCC);
var source = _image01;
var sourceRect = new createjs.Rectangle(0, 0, _image01.width, _image01.height);
var destPoint;
var alphaSource = _maskImage;
var alphaPoint = new createjs.Point();
var mergeAlpha = true;
destPoint = new createjs.Point(10, 80);
_bmd01.copyPixels(source, sourceRect, destPoint);
destPoint = new createjs.Point(220, 80);
_bmd01.copyPixels(source, sourceRect, destPoint, alphaSource);
destPoint = new createjs.Point(430, 80);
_bmd01.copyPixels(source, sourceRect, destPoint, alphaSource, alphaPoint, mergeAlpha);&lt;/code&gt;&lt;/pre&gt;
	**/
	p.copyPixels = function(source, sourceRect, destPoint, alphaSource, alphaPoint, mergeAlpha) {
		var sx = sourceRect.x &gt;&gt; 0;
		var sy = sourceRect.y &gt;&gt; 0;
		var sw = sourceRect.width &gt;&gt; 0;
		var sh = sourceRect.height &gt;&gt; 0;
		var dx = destPoint.x &gt;&gt; 0;
		var dy = destPoint.y &gt;&gt; 0;
		var sContext = getSourceContext(source, sx + sw, sy + sh);
		var sImgData = sContext.getImageData(sx, sy, sw, sh);
		if (!!alphaSource) {
			var ax, ay;
			if (alphaPoint) {
				ax = alphaPoint.x &gt;&gt; 0;
				ay = alphaPoint.y &gt;&gt; 0;
			} else {
				ax = 0;
				ay = 0;
			}
			var aContext = getSourceContext(alphaSource, ax + sw, ay + sh);
			var aImgData = aContext.getImageData(ax, ay, sw, sh);
			var sData = sImgData.data;
			var aData = aImgData.data;
			for (var i = 3, l = sData.length; i &lt; l; i += 4) {
				sData[i] = aData[i];
			}
			if (mergeAlpha) {
				sContext.putImageData(sImgData, sx, sy);
				this.context.drawImage(sContext.canvas, sx, sy, sw, sh, dx, dy, sw, sh);
			} else {
				this.context.putImageData(sImgData, dx, dy);
			}
		} else {
			this.context.putImageData(sImgData, dx, dy);
		}
		this._contextChanged = true;
	};

	/**
	* BitmapDataオブジェクトの格納に使用されるメモリを解放します。
	* @method dispose
	**/
	p.dispose = function() {
		delete this._imageData;
		delete this.context;
		delete this.canvas;
	};

	/**
	* ソースオブジェクトを現在のBitmapDataに描画します。
	* @method draw
	* @param source {BitmapData | DisplayObject | Stage | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} ソースとなるオブジェクトを指定します。
	* @param [matrix=null] {Matrix2D} ソースオブジェクトに適用する変換行列を指定します。変換行列を指定したくない場合はnullを指定して下さい。
	* @param [colorTransform=null] {ColorTransform} ソースオブジェクトに適用するColorTransformオブジェクトを指定します。ColorTransformを適用したくない場合はnullを指定して下さい。
	* @param [compositeOperation=null] {String} 描画時のcanvasのglobalCompositeOperationの値です。
	* @param [clipRect=null] {Rectangle} 描画時のクリッピング領域を示すRectangleです。
	* @param [smoothing=false] {Boolean} 描画時にスムージングを適用するかをBool値で指定します。
	* @example
	* &lt;pre&gt;&lt;code&gt;var matrix = new createjs.Matrix2D(1, 0, 0, 1, -_sourceRect.width &amp;gt;&amp;gt; 1, -_sourceRect.height &amp;gt;&amp;gt; 1);
var rotation = Math.random() * 360 &amp;gt;&amp;gt; 0;
matrix.rotate(rotation * createjs.Matrix2D.DEG_TO_RAD);
var scale = Math.random() * 0.5 + 0.5;
matrix.scale(scale, scale);
var tx = Math.random() * _bmd01.width &amp;gt;&amp;gt; 0;
var ty = Math.random() * _bmd01.height &amp;gt;&amp;gt; 0;
matrix.translate(tx, ty);
var red = (Math.random() * 224 &amp;gt;&amp;gt; 0) + 32;
var green = (Math.random() * 224 &amp;gt;&amp;gt; 0) + 32;
var blue = (Math.random() * 224 &amp;gt;&amp;gt; 0) + 32;
var colorTransform = new createjs.ColorTransform(0, 0, 0, 1, red, green, blue);
var compositeOperation = &amp;quot;lighter&amp;quot;;
var clipRect = null;
var smoothing = true;
_bmd01.draw(_source, matrix, colorTransform, compositeOperation, clipRect, smoothing);&lt;/code&gt;&lt;/pre&gt;
	**/
	p.draw = function(source, matrix, colorTransform, compositeOperation, clipRect, smoothing) {
		if (source instanceof BitmapData || source instanceof createjs.Stage) {
			source = source.canvas;
		} else if (source instanceof createjs.DisplayObject) {
			if (!!source.cacheCanvas) {
				source = source.cacheCanvas;
			} else {
				throw new Error(&quot;The source of BitmapData.draw(), must be called DisplayObject.cache().&quot;);
			}
		} else if (source instanceof HTMLImageElement || source instanceof HTMLVideoElement) {
			var sCvs = createCanvas(source.width, source.height);
			var sCtx = sCvs.getContext(&quot;2d&quot;);
			sCtx.drawImage(source, 0, 0);
			source = sCvs;
		}
		matrix = matrix || new createjs.Matrix2D();
		var bmd;
		if (!!colorTransform) {
			var sw = source.width;
			var sh = source.height;
			bmd = new BitmapData(source, sw, sh);
			bmd.colorTransform(new createjs.Rectangle(0, 0, sw, sh), colorTransform);
			source = bmd.canvas;
		}
		smoothing = !!smoothing;
		var ctx = this.context;
		ctx.save();
		if (!!compositeOperation) ctx.globalCompositeOperation = compositeOperation;
		ctx.imageSmoothingEnabled = smoothing;
		ctx.webkitImageSmoothingEnabled = smoothing;
		ctx.mozImageSmoothingEnabled = smoothing;
		if (!!clipRect) {
			ctx.rect(clipRect.x, clipRect.y, clipRect.width, clipRect.height);
			ctx.clip();
		}
		ctx.setTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
		ctx.drawImage(source, 0, 0);
		ctx.restore();
		if (!!bmd) {
			bmd.dispose();
		}
		this._contextChanged = true;
	};

	/**
	* ソースオブジェクトを現在のBitmapDataに描画します。変換行列やColorTransformを使用しないので、draw()よりも高速に動作します。このメソッドは、CanvasRenderingContext2DのdrawImage()と同様の動作を提供します。
	* @method drawImage
	* @param source {BitmapData | DisplayObject | Stage | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} ソースとなるオブジェクトを指定します。
	* @param [sx=0] {Number} ソースオブジェクトの左上x座標です。第6引数以降を省略した場合、この引数はdxとして動作します。
	* @param [sy=0] {Number} ソースオブジェクトの左上y座標です。第6引数以降を省略した場合、この引数はdyとして動作します。
	* @param [sw] {Number} ソースオブジェクトの幅です。第6引数以降を省略した場合、この引数はdwとして動作します。
	* @param [sh] {Number} ソースオブジェクトの高さです。第6引数以降を省略した場合、この引数はdhとして動作します。
	* @param [dx] {Number} 描画先の左上x座標です。
	* @param [dy] {Number} 描画先の左上y座標です。
	* @param [dw] {Number} 描画時の幅です。
	* @param [dh] {Number} 描画時の高さです。
	**/
	p.drawImage = function(source, sx, sy, sw, sh, dx, dy, dw, dh) {
		if (source instanceof BitmapData || source instanceof createjs.Stage) {
			source = source.canvas;
		} else if (source instanceof createjs.DisplayObject) {
			if (!!source.cacheCanvas) {
				source = source.cacheCanvas;
			} else {
				throw new Error(&quot;The source of BitmapData.drawImage(), must be called DisplayObject.cache().&quot;);
			}
		}
		if (dx !== undefined) {
			this.context.drawImage(source, sx, sy, sw, sh, dx, dy, dw, dh);
		} else if (sw !== undefined) {
			dx = sx;
			dy = sy;
			dw = sw;
			dh = sh;
			this.context.drawImage(source, dx, dy, dw, dh);
		} else {
			dx = sx || 0;
			dy = sy || 0;
			this.context.drawImage(source, dx, dy);
		}
		this._contextChanged = true;
	};

	/**
	* BitmapDataのサイズを変更します。引数のRectangleは、Filter.getBounds()の戻り値に合わせています。例として、上下左右に8pxずつ拡げたい場合は、new createjs.Rectangle(-8, -8, 16, 16)を指定します。
	* @method expand
	* @param rect {Rectangle} BitmapDataのサイズ変更に使用するRectangleです。Filterを使用する場合は、Filter.getBounds()の戻り値をそのまま渡します。
	* @example
	* &lt;pre&gt;&lt;code&gt;_bmd01 = new createjs.BitmapData(_image01);
var source = _bmd01;
var filter = new createjs.BlurFilter(16, 16, 1);
var rect = filter.getBounds();
_bmd01.expand(rect);
var sourceRect = new createjs.Rectangle(0, 0, _bmd01.width, _bmd01.height);
var destPoint = new createjs.Point();
_bmd01.applyFilter(source, sourceRect, destPoint, filter);&lt;/code&gt;&lt;/pre&gt;
	**/
	p.expand = function(rect) {
		var x = rect.x &gt;&gt; 0;
		var y = rect.y &gt;&gt; 0;
		var w = rect.width &gt;&gt; 0;
		var h = rect.height &gt;&gt; 0;
		var cvs = createCanvas(this.canvas.width + w, this.canvas.height + h);
		var ctx = cvs.getContext(&quot;2d&quot;);
		ctx.drawImage(this.canvas, -x, -y);
		this.canvas = cvs;
		this.context = ctx;
		this._contextChanged = true;
	};

	/**
	* BitmapDataの特定領域を指定されたカラー値で塗りつぶします。
	* @method fillRect
	* @param rect {Rectangle} 塗りつぶす範囲を示すRectangleです。
	* @param color {String | uint} 塗りつぶしのカラー値です。CSS文字列と0xAARRGGBB形式の16進数値が使えます。16進数値で指定する際にアルファ値として0を指定した場合は、0xRRGGBBとして処理を行います。例として、0x00FF0000を指定した場合は、0xFF0000として処理されます。ピクセルを透明にしたい場合はclearRect()を使用して下さい。
	* @example
	* &lt;pre&gt;&lt;code&gt;_bmd01 = new createjs.BitmapData(null, 200, 200);
_bmd02 = _bmd01.clone();
var rect = new createjs.Rectangle(0, 0, 200, 200);
var color01 = 0x80FF0000;
_bmd01.fillRect(rect, color01);
var color02 = createjs.Graphics.getRGB(0, 0, 255, 0.5)
_bmd02.fillRect(rect, color02);&lt;/code&gt;&lt;/pre&gt;
	**/
	p.fillRect = function(rect, color) {
		if (!isNaN(color)) {
			var r = color &gt;&gt; 16 &amp; 0xFF;
			var g = color &gt;&gt; 8 &amp; 0xFF;
			var b = color &amp; 0xFF;
			var a = (color &gt;&gt; 24 &amp; 0xFF) / 255;
			if (a === 0) {
				color = &quot;rgb(&quot; + r + &quot;,&quot; + g + &quot;,&quot; + b + &quot;)&quot;;
			} else {
				color = &quot;rgba(&quot; + r + &quot;,&quot; + g + &quot;,&quot; + b + &quot;,&quot; + a + &quot;)&quot;;
			}
		}
		var ctx = this.context;
		ctx.save();
		ctx.fillStyle = color;
		ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
		ctx.restore();
		this._contextChanged = true;
	};

	/**
	* 指定した座標を始点として、上下左右に連続した色をバケツツールのように塗りつぶします。
	* @method floodFill
	* @param x {uint} 塗りつぶしの始点となるx座標です。
	* @param y {uint} 塗りつぶしの始点となるy座標です。
	* @param color {uint} 塗りつぶしのカラー値です。0xAARRGGBB形式の16進数値のみ使用できます。
	* @example
	* &lt;pre&gt;&lt;code&gt;function clickHandler(evt) {
  _bmd01.floodFill(evt.stageX, evt.stageY, 0xFFCCCCCC);
  _stage.update();
}&lt;/code&gt;&lt;/pre&gt;
	**/
	p.floodFill = function(x, y, color) {
		if (this._contextChanged) this.updateImageData();
		var imgData = this._imageData;
		var w = imgData.width;
		var h = imgData.height;
		x = x &gt;&gt; 0;
		y = y &gt;&gt; 0;
		if (x &lt; 0 || y &lt; 0 || w &lt;= x || h &lt;= y) {
			return;
		}
		var targetColor = this.getPixel32(x, y);
		if (targetColor === color) {
			return;
		}
		var d = imgData.data;
		var buffer = [new createjs.Point(x, y)];
		while (buffer.length) {
			var p = buffer.shift();
			var px = p.x;
			var py = p.y;
			if (this.getPixel32(px, py) === color) {
				continue;
			}
			for (var xl = px; 0 &lt; xl; xl--) {
				if (this.getPixel32(xl - 1, py) !== targetColor) {
					break;
				}
			}
			for (var xr = px; xr &lt; w - 1; xr++) {
				if (this.getPixel32(xr + 1, py) !== targetColor) {
					break;
				}
			}
			for (var i = xl; i &lt;= xr; i++) {
				this.setPixel32(i, py, color);
			}
			if (py + 1 &lt; h) scanLine.call(this, xl, xr, py + 1, targetColor, buffer);
			if (0 &lt;= py - 1) scanLine.call(this, xl, xr, py - 1, targetColor, buffer);
		}
		this.updateContext();
	};

	function scanLine(xl, xr, y, targetColor, buffer) {
		while (xl &lt;= xr) {
			while (xl &lt;= xr) {
				if (this.getPixel32(xl, y) === targetColor) {
					break;
				}
				xl++;
			}
			if (xr &lt; xl) {
				break;
			}
			xl++;
			while (xl &lt;= xr) {
				if (this.getPixel32(xl, y) !== targetColor) {
					break;
				}
				xl++;
			}
			buffer.push(new createjs.Point(xl - 1, y));
		}
	}

	/**
	* 引数findColorにtrueを指定した場合は、指定された色のピクセルを囲むRectangleを返します。findColorにfalseを指定した場合は、指定された色ではないピクセルを囲むRectangleを返します。
	* @method getColorBoundsRect
	* @param mask {uint} ピクセルのカラー値をマスクする16進数値を指定します。ピクセルのカラー値とこの16進数値は、AND論理演算子でつなげられます。
	* @param color {uint} 対象とするカラー値を指定します。0xAARRGGBB形式の16進数値のみ使用できます。
	* @param [findColor=false] {Boolean} trueを指定した場合、指定された色のピクセルを囲むRectangleを返します。falseを指定した場合、指定された色ではないピクセルを囲むRectangleを返します。
	* @return {Rectangle} 条件に合致したすべてのピクセルを囲むRectangleです。条件に合致するピクセルがない場合は、Rectangle(0, 0, 0, 0)を返します。
	**/
	p.getColorBoundsRect = function(mask, color, findColor) {
		if (findColor === undefined) findColor = true;
		if (this._contextChanged) this.updateImageData();
		var imgData = this._imageData;
		var w = imgData.width;
		var h = imgData.height;
		var d = imgData.data;
		var xMin = NaN, xMax = NaN, yMin = NaN, yMax = NaN;
		for (var i = 0, l = d.length; i &lt; l; i += 4) {
			var value = ((d[i + 3] &lt;&lt; 24 | d[i] &lt;&lt; 16 | d[i + 1] &lt;&lt; 8 | d[i + 2]) &amp; mask) &gt;&gt;&gt; 0;
			if ((findColor &amp;&amp; (value === color)) || (!findColor &amp;&amp; (value !== color))) {
				var p = i / 4;
				var x = p % w;
				var y = p / w &gt;&gt; 0;
				if (isNaN(xMin)) {
					xMin = xMax = x;
					yMin = yMax = y;
				} else {
					if (x &lt; xMin) xMin = x;
					if (xMax &lt; x) xMax = x;
					if (y &lt; yMin) yMin = y;
					if (yMax &lt; y) yMax = y;
				}
			}
			if (xMin === 0 &amp;&amp; xMax === w - 1 &amp;&amp; yMin === 0 &amp;&amp; yMax === h - 1) {
				break;
			}
		}
		if (isNaN(xMin)) {
			return new createjs.Rectangle();
		} else {
			return new createjs.Rectangle(xMin, yMin, xMax - xMin + 1, yMax - yMin + 1);
		}
	};

	/**
	* 指定された座標のRGBカラー値を数値で返します。
	* @method getPixel
	* @param x {uint} カラー値を取得するx座標です。
	* @param y {uint} カラー値を取得するy座標です。
	* @return {uint} RGBカラー値を表す数値です。
	* @example
	* &lt;pre&gt;&lt;code&gt;var color = forcemap.getPixel(x, y);&lt;/code&gt;&lt;/pre&gt;
	**/
	p.getPixel = function(x, y) {
		x = x &gt;&gt; 0;
		y = y &gt;&gt; 0;
		if (this._contextChanged) this.updateImageData();
		var imgData = this._imageData;
		var w = imgData.width;
		var h = imgData.height;
		if (w &lt;= x || h &lt;= y) {
			return 0;
		}
		var d = imgData.data;
		var i = ((w * y) + x) * 4;
		var r = d[i];
		var g = d[++i];
		var b = d[++i];
		return r &lt;&lt; 16 | g &lt;&lt; 8 | b;
	};

	/**
	* 指定された座標のARGBカラー値を数値で返します。
	* @method getPixel32
	* @param x {uint} カラー値を取得するx座標です。
	* @param y {uint} カラー値を取得するy座標です。
	* @return {uint} ARGBカラー値を表す数値です。
	**/
	p.getPixel32 = function(x, y) {
		x = x &gt;&gt; 0;
		y = y &gt;&gt; 0;
		if (this._contextChanged) this.updateImageData();
		var imgData = this._imageData;
		var w = imgData.width;
		var h = imgData.height;
		if (w &lt;= x || h &lt;= y) {
			return 0;
		}
		var d = imgData.data;
		var i = ((w * y) + x) * 4;
		var r = d[i];
		var g = d[++i];
		var b = d[++i];
		var a = d[++i];
		return (a &lt;&lt; 24 | r &lt;&lt; 16 | g &lt;&lt; 8 | b) &gt;&gt;&gt; 0;
	};

	/**
	* 引数で指定された領域のピクセルデータをUint8ClampedArray（旧ブラウザではCanvasPixelArray）で返します。戻り値のピクセルデータは、R, G, B, Aの並びになっています。
	* @method getPixels
	* @param rect {Rectangle} ピクセルデータを取得する範囲を示すRectangleです。
	* @return {Uint8ClampedArray} 指定された範囲のimageData.dataプロパティを返します。
	* @example
	* &lt;pre&gt;&lt;code&gt;_bmd01 = new createjs.BitmapData(_image01);
_bmd02 = new createjs.BitmapData(_image02);
var rect = new createjs.Rectangle(20, 20, 160, 160);
var data01 = _bmd01.getPixels(rect);
var data02 = _bmd02.getPixels(rect);
for (var i = 0, l = data01.length; i &amp;lt; l; i += 4) {
  if (i / 4 % 2 !== 0) {
    var r = i;
    var g = i + 1;
    var b = i + 2;
    var a = i + 3;
    data01[r] = data02[r];
    data01[g] = data02[g];
    data01[b] = data02[b];
    data01[a] = data02[a];
  }
}
_bmd01.setPixels(rect, data01);&lt;/code&gt;&lt;/pre&gt;
	**/
	p.getPixels = function(rect) {
		return this.context.getImageData(rect.x &gt;&gt; 0, rect.y &gt;&gt; 0, rect.width &gt;&gt; 0, rect.height &gt;&gt; 0).data;
	};

	/**
	* BitmapDataのヒストグラムを2次元配列で返します。戻り値の配列は、[[R], [G], [B], [A]]の形式で4つの配列を格納しています。各カラー値の配列は、0～255のindexを持っており、そこにカラー値のポピュレーションカウントを格納しています。
	* @method histogram
	* @param hRect {Rectangle} ヒストグラムを取得する範囲を示すRectangleです。
	* @return {Array} BitmapDataのヒストグラムを表す2次元配列です。
	**/
	p.histogram = function(hRect) {
		var h = [[], [], [], []];
		for (var i = 0, l = 256; i &lt; l; i++) {
			h[0][i] = 0;
			h[1][i] = 0;
			h[2][i] = 0;
			h[3][i] = 0;
		}
		var imgData = this.context.getImageData(hRect.x &gt;&gt; 0, hRect.y &gt;&gt; 0, hRect.width &gt;&gt; 0, hRect.height &gt;&gt; 0);
		var d = imgData.data;
		for (i = 0, l = d.length; i &lt; l; i += 4) {
			h[0][d[i]]++;
			h[1][d[i + 1]]++;
			h[2][d[i + 2]]++;
			h[3][d[i + 3]]++;
		}
		return h;
	};

	/**
	* アルファチャンネルを含めたピクセルレベルの衝突判定を行います。対象オブジェクトがPoint, Rectangleの場合には第4引数以降は必要ありません。
	* @method hitTest
	* @param firstPoint {Point} 任意の座標空間における現在のBitmapDataの座標を示すPointです。
	* @param firstAlphaThreshold {uint} 現在のBitmapDataで不透明とするアルファチャンネルのしきい値です。
	* @param secondObject {Point | Rectangle | BitmapData | DisplayObject | Stage | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} 衝突判定の対象となるオブジェクトです。
	* @param [secondObjectPoint=null] {Point} secondObjectの座標を示すPointです。
	* @param [secondAlphaThreshold=1] {uint} secondObjectで不透明とするアルファチャンネルのしきい値です。
	* @return {Boolean} 衝突している場合はtrue、していない場合はfalseを返します。
	* @example
	* &lt;pre&gt;&lt;code&gt;var firstPoint = new createjs.Point(_bitmap01.x, _bitmap01.y);
var firstAlphaThreshold = 0xFF;
var secondObject = _shape_bmd;
var secondObjectPoint = new createjs.Point(_shape.x - 20, _shape.y - 20);
var secondAlphaThreshold = 0x80;
if (_bmd01.hitTest(firstPoint, firstAlphaThreshold, secondObject, secondObjectPoint, secondAlphaThreshold)) {
  if (!_isHitting) {
    changeColor(&amp;quot;rgba(0,255,0,0.75)&amp;quot;);
  }
} else {
  if (_isHitting) {
    changeColor(&amp;quot;rgba(0,0,255,0.75)&amp;quot;);
  }
}&lt;/code&gt;&lt;/pre&gt;
	**/
	p.hitTest = function(firstPoint, firstAlphaThreshold, secondObject, secondObjectPoint, secondAlphaThreshold) {
		var fx = firstPoint.x &gt;&gt; 0;
		var fy = firstPoint.y &gt;&gt; 0;
		var w = this.canvas.width;
		var h = this.canvas.height;
		if (this._contextChanged) this.updateImageData();
		var data = this._imageData.data;
		var sx, sy;
		if (secondObject instanceof createjs.Point) {
			sx = (secondObject.x &gt;&gt; 0) - fx;
			sy = (secondObject.y &gt;&gt; 0) - fy;
			if (w &lt;= sx || h &lt;= sy || sx &lt; 0 || sy &lt; 0) {
				return false;
			}
			return firstAlphaThreshold &lt;= data[((w * sy) + sx) * 4 + 3];
		}
		var area, ax, ay, aw, ah;
		if (secondObject instanceof createjs.Rectangle) {
			secondObject.x = (secondObject.x &gt;&gt; 0) - fx;
			secondObject.y = (secondObject.y &gt;&gt; 0) - fy;
			area = getIntersection(new createjs.Rectangle(0, 0, w, h), secondObject);
			if (area === 0) {
				return false;
			}
			for (ay = area.y, ah = ay + area.height; ay &lt; ah; ay++) {
				for (ax = area.x, aw = ax + area.width; ax &lt; aw; ax++) {
					if (firstAlphaThreshold &lt;= data[((w * ay) + ax) * 4 + 3]) {
						return true;
					}
				}
			}
			return false;
		}
		var sCtx = getSourceContext(secondObject, secondObject.width, secondObject.height);
		if (!sCtx) {
			throw new Error(&quot;The secondObject must be Point, Rectangle, BitmapData, cached DisplayObject.&quot;);
		}
		secondObjectPoint = secondObjectPoint || new createjs.Point();
		secondAlphaThreshold = secondAlphaThreshold || 1;
		sx = (secondObjectPoint.x &gt;&gt; 0) - fx;
		sy = (secondObjectPoint.y &gt;&gt; 0) - fy;
		var sCvs = sCtx.canvas;
		area = getIntersection(new createjs.Rectangle(0, 0, w, h), new createjs.Rectangle(sx, sy, sCvs.width, sCvs.height));
		if (area === 0) {
			return false;
		}
		var sox = area.x;
		var soy = area.y;
		var sow = area.width;
		var soh = area.height;
		var sImgData = sCtx.getImageData(sox - sx, soy - sy, sow, soh);
		var sData = sImgData.data;
		for (ay = soy, ah = ay + soh; ay &lt; ah; ay++) {
			for (ax = sox, aw = ax + sow; ax &lt; aw; ax++) {
				if (secondAlphaThreshold &lt;= sData[((sow * (ay - soy)) + (ax - sox)) * 4 + 3]) {
					if (firstAlphaThreshold &lt;= data[((w * ay) + ax) * 4 + 3]) {
						return true;
					}
				}
			}
		}
		return false;
	};

	function getIntersection(rect1, rect2) {
		var w1 = rect1.width;
		var h1 = rect1.height;
		var w2 = rect2.width;
		var h2 = rect2.height;
		if (w1 === 0 || h1 === 0 || w2 === 0 || h2 === 0) {
			return 0;
		}
		var l1 = rect1.x;
		var r1 = l1 + w1;
		var t1 = rect1.y;
		var b1 = t1 + h1;
		var l2 = rect2.x;
		var r2 = l2 + w2;
		var t2 = rect2.y;
		var b2 = t2 + h2;
		if (l1 &lt; r2 &amp;&amp; t1 &lt; b2 &amp;&amp; l2 &lt; r1 &amp;&amp; t2 &lt; b1) {
			var l = (l1 &lt; l2) ? l2 : l1;
			var r = (r2 &lt; r1) ? r2 : r1;
			var t = (t1 &lt; t2) ? t2 : t1;
			var b = (b2 &lt; b1) ? b2 : b1;
			return new createjs.Rectangle(l, t, r - l, b - t);
		} else {
			return 0;
		}
	}

	/**
	* 現在のBitmapDataとソースオブジェクトをチャンネルごとにブレンドします。
	* @method merge
	* @param source {BitmapData | DisplayObject | Stage | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} ソースとなるオブジェクトを指定します。
	* @param sourceRect {Rectangle} ソースオブジェクトの範囲を示すRectangleです。
	* @param destPoint {Point} マージ先の左上座標を示すPointです。
	* @param redMultiplier {uint} 赤チャンネル値に乗算する数値です。
	* @param greenMultiplier {uint} 緑チャンネル値に乗算する数値です。
	* @param blueMultiplier {uint} 青チャンネル値に乗算する数値です。
	* @param alphaMultiplier {uint} アルファチャンネル値に乗算する数値です。
	* @example
	* &lt;pre&gt;&lt;code&gt;_bmd01 = new createjs.BitmapData(_image01);
_bmd02 = _bmd01.clone();
_bmd03 = new createjs.BitmapData(_image02);
var source = _bmd03;
var sourceRect = new createjs.Rectangle(0, 0, _image02.width, _image02.height);
var destPoint = new createjs.Point();
var redMultiplier = 192;
var greenMultiplier = 64;
var blueMultiplier = 128;
var alphaMultiplier = 128;
_bmd02.merge(source, sourceRect, destPoint, redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier);&lt;/code&gt;&lt;/pre&gt;
	**/
	p.merge = function(source, sourceRect, destPoint, redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier) {
		var sx = sourceRect.x &gt;&gt; 0;
		var sy = sourceRect.y &gt;&gt; 0;
		var sw = sourceRect.width &gt;&gt; 0;
		var sh = sourceRect.height &gt;&gt; 0;
		var dx = destPoint.x &gt;&gt; 0;
		var dy = destPoint.y &gt;&gt; 0;
		var sContext = getSourceContext(source, sx + sw, sy + sh);
		var sImgData = sContext.getImageData(sx, sy, sw, sh);
		var sData = sImgData.data;
		var dContext = this.context;
		var dImgData = dContext.getImageData(dx, dy, sw, sh);
		var dData = dImgData.data;
		for (var i = 0, l = dData.length; i &lt; l; i += 4) {
			var r = i;
			var g = i + 1;
			var b = i + 2;
			var a = i + 3;
			dData[r] = ((sData[r] * redMultiplier) + (dData[r] * (256 - redMultiplier))) / 256;
			dData[g] = ((sData[g] * greenMultiplier) + (dData[g] * (256 - greenMultiplier))) / 256;
			dData[b] = ((sData[b] * blueMultiplier) + (dData[b] * (256 - blueMultiplier))) / 256;
			dData[a] = ((sData[a] * alphaMultiplier) + (dData[a] * (256 - alphaMultiplier))) / 256;
		}
		dContext.putImageData(dImgData, dx, dy);
		this._contextChanged = true;
	};

	/**
	* ランダムノイズを生成します。
	* @method noise
	* @param [low=0] {uint} チャンネルごとに生成する最小値です。
	* @param [high=255] {uint} チャンネルごとに生成する最大値です。
	* @param [channelOptions=7] {uint} 対象とするチャンネルを指定します。BitmapDataChannelクラスの定数が使え、OR論理演算子で複数のチャンネルを組み合わせることができます。
	* @param [grayScale=false] {Boolean} ノイズをグレイスケールにするかをBool値を指定します。trueにした場合、アルファチャンネルを除いたすべてのチャンネルが同じ値となります。
	* @example
	* &lt;pre&gt;&lt;code&gt;_bmd01 = new createjs.BitmapData(null, 200, 200);
var low = 128;
var high = 200;
var channel = Object.create(createjs.BitmapDataChannel);
var channelOptions = channel.BLUE | channel.ALPHA;
var grayScale = false;
_bmd01.noise(low, high, channelOptions, grayScale);&lt;/code&gt;&lt;/pre&gt;
	**/
	p.noise = function(low, high, channelOptions, grayScale) {
		low = low || 0;
		high = high || 255;
		var range = high - low;
		channelOptions = channelOptions || 7;
		grayScale = !!grayScale;
		var channel = Object.create(BitmapDataChannel);
		var red = (channelOptions &amp; channel.RED) === channel.RED;
		var green = (channelOptions &amp; channel.GREEN) === channel.GREEN;
		var blue = (channelOptions &amp; channel.BLUE) === channel.BLUE;
		var alpha = (channelOptions &amp; channel.ALPHA) === channel.ALPHA;
		var d = this._imageData.data;
		for (var i = 0, l = d.length; i &lt; l; i += 4) {
			var r = i;
			var g = i + 1;
			var b = i + 2;
			var a = i + 3;
			if (grayScale) {
				d[r] = d[g] = d[b] = (Math.random() * range &gt;&gt; 0) + low;
			} else {
				d[r] = (red) ? (Math.random() * range &gt;&gt; 0) + low : 0;
				d[g] = (green) ? (Math.random() * range &gt;&gt; 0) + low : 0;
				d[b] = (blue) ? (Math.random() * range &gt;&gt; 0) + low : 0;
			}
			d[a] = (alpha) ? (Math.random() * range &gt;&gt; 0) + low : 255;
		}
		this.updateContext();
	};

	/**
	* カラーパレットデータ配列を使用して、BitmapDataのカラー値をマッピングします。パレットデータ配列でnullを指定したチャンネルでは、ソースオブジェクトのチャンネルが使用されます。各チャンネルのパレットデータ配列には、256個の値が含まれている必要があります。
	* @method paletteMap
	* @param source {BitmapData | DisplayObject | Stage | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} ソースとなるオブジェクトを指定します。
	* @param sourceRect {Rectangle} ソースオブジェクトの範囲を示すRectangleです。
	* @param destPoint {Point} マッピング先の左上座標を示すPointです。
	* @param [redArray=null] {Array} 赤チャンネルのマッピングに使用するパレットデータ配列です。
	* @param [greenArray=null] {Array} 緑チャンネルのマッピングに使用するパレットデータ配列です。
	* @param [blueArray=null] {Array} 青チャンネルのマッピングに使用するパレットデータ配列です。
	* @param [alphaArray=null] {Array} アルファチャンネルのマッピングに使用するパレットデータ配列です。
	* @example
	* &lt;pre&gt;&lt;code&gt;_bmd01 = new createjs.BitmapData(_image01);
var source = _bmd01;
var sourceRect = new createjs.Rectangle(64, 48, 256, 144);
var destPoint = new createjs.Point(sourceRect.x, sourceRect.y);
var redArray = [], greenArray = [], blueArray = [], alphaArray = null;
for (var i = 0, l = 256; i &amp;lt; l; i++) {
  redArray[i] = (255 - i) &amp;lt;&amp;lt; 16;
  greenArray[i] = (255 - i) &amp;lt;&amp;lt; 8;
  blueArray[i] = 255 - i;
}
_bmd01.paletteMap(source, sourceRect, destPoint, redArray, greenArray, blueArray, alphaArray);&lt;/code&gt;&lt;/pre&gt;
	**/
	p.paletteMap = function(source, sourceRect, destPoint, redArray, greenArray, blueArray, alphaArray) {
		var sx = sourceRect.x &gt;&gt; 0;
		var sy = sourceRect.y &gt;&gt; 0;
		var sw = sourceRect.width &gt;&gt; 0;
		var sh = sourceRect.height &gt;&gt; 0;
		var dx = destPoint.x &gt;&gt; 0;
		var dy = destPoint.y &gt;&gt; 0;
		var sContext = getSourceContext(source, sx + sw, sy + sh);
		var sImgData = sContext.getImageData(sx, sy, sw, sh);
		var sData = sImgData.data;
		var dContext = this.context;
		var dImgData = dContext.getImageData(dx, dy, sw, sh);
		var dData = dImgData.data;
		for (var i = 0, l = dData.length; i &lt; l; i += 4) {
			var r = i;
			var g = i + 1;
			var b = i + 2;
			var a = i + 3;
			var red = (redArray) ? redArray[sData[r]] : sData[r] &lt;&lt; 16;
			var green = (greenArray) ? greenArray[sData[g]] : sData[g] &lt;&lt; 8;
			var blue = (blueArray) ? blueArray[sData[b]] : sData[b];
			var alpha = (alphaArray) ? alphaArray[sData[a]] : (sData[a] &lt;&lt; 24) &gt;&gt;&gt; 0;
			dData[r] = ((red &gt;&gt; 16 &amp; 0xFF) + (green &gt;&gt; 16 &amp; 0xFF) + (blue &gt;&gt; 16 &amp; 0xFF) + (alpha &gt;&gt; 16 &amp; 0xFF)) % 256;
			dData[g] = ((red &gt;&gt; 8 &amp; 0xFF) + (green &gt;&gt; 8 &amp; 0xFF) + (blue &gt;&gt; 8 &amp; 0xFF) + (alpha &gt;&gt; 8 &amp; 0xFF)) % 256;
			dData[b] = ((red &amp; 0xFF) + (green &amp; 0xFF) + (blue &amp; 0xFF) + (alpha &amp; 0xFF)) % 256;
			dData[a] = ((red &gt;&gt; 24 &amp; 0xFF) + (green &gt;&gt; 24 &amp; 0xFF) + (blue &gt;&gt; 24 &amp; 0xFF) + (alpha &gt;&gt; 24 &amp; 0xFF)) % 256;
		}
		dContext.putImageData(dImgData, dx, dy);
		this._contextChanged = true;
	};

	/**
	* PerlinNoiseを生成します。
	* @method perlinNoise
	* @param baseX {Number} x方向で使用する周波数です。
	* @param baseY {Number} y方向で使用する周波数です。
	* @param numOctaves {uint} PerlinNoiseを作成するために組み合わせるオクターブの数です。オクターブ数を大きくすると、よりきめ細かいノイズを作成できますが、その分、処理に時間がかかります。
	* @param randomSeed {int} ノイズの生成に使用するランダムシード（乱数の種）を指定します。同じランダムシードからは、毎回同じ結果が得られます。
	* @param [stitch=false] {Boolean} trueを指定した場合、タイリングに適したシームレスなPerlinNoiseを生成しますが、その分、処理に時間がかかります。
	* @param [fractalNoise=false] {Boolean} trueを指定した場合、フラクタルノイズを生成します。
	* @param [channelOptions=7] {uint} 対象とするチャンネルを指定します。BitmapDataChannelクラスの定数が使え、OR論理演算子で複数のチャンネルを組み合わせることができます。
	* @param [grayScale=false] {Boolean} trueを指定した場合、RGBの各カラーチャンネルに同じ値を設定して、グレースケールのノイズが作成されます。この値はアルファチャンネルには影響しません。
	* @param [offsets=null] {Array} 各オクターブのオフセット値を格納した配列です。オフセット値はPointインスタンスで指定します。
	* @param [interpolateType=&quot;linear&quot;] {String} ノイズを滑らかにする補間のタイプを&quot;linear&quot;と&quot;cos&quot;から選択できます。&quot;cos&quot;の方が滑らかな結果が得られますが、その分、処理に時間がかかります。デフォルト値は&quot;linear&quot;です。
	* @example
	* &lt;pre&gt;&lt;code&gt;_bmd01 = new createjs.BitmapData(null, 320, 240);
var baseX = _bmd01.width;
var baseY = _bmd01.height;
var numOctaves = 5;
var randomSeed = 7;
var stitch = false;
var fractalNoise = false;
var channel = Object.create(createjs.BitmapDataChannel);
var channelOptions = channel.RED | channel.GREEN | channel.BLUE;
var grayScale = true;
var offsets = [new createjs.Point(0, 0), new createjs.Point(0, 0)];
var interpolateType = &quot;cos&quot;;
_bmd01.perlinNoise(baseX, baseY, numOctaves, randomSeed, stitch, fractalNoise, channelOptions, grayScale, offsets, interpolateType);&lt;/code&gt;&lt;/pre&gt;
	**/
	p.perlinNoise = function(baseX, baseY, numOctaves, randomSeed, stitch, fractalNoise, channelOptions, grayScale, offsets, interpolateType) {
		if (numOctaves === 0) {
			this.fillRect(new createjs.Rectangle(0, 0, this.canvas.width, this.canvas.height), 0);
			return;
		}
		baseX = baseX || 1;
		baseY = baseY || 1;
		stitch = !!stitch;
		fractalNoise = !!fractalNoise;
		channelOptions = channelOptions || 7;
		grayScale = !!grayScale;
		offsets = offsets || [];
		interpolateType = interpolateType || &quot;linear&quot;;
		NoiseGenerator.setProperties(randomSeed, interpolateType);
		var channels = [];
		var bc = Object.create(BitmapDataChannel);
		if (!grayScale) {
			var chR = channels[0] = (channelOptions &amp; bc.RED) === bc.RED;
			var chG = channels[1] = (channelOptions &amp; bc.GREEN) === bc.GREEN;
			var chB = channels[2] = (channelOptions &amp; bc.BLUE) === bc.BLUE;
		}
		var chA = channels[3] = (channelOptions &amp; bc.ALPHA) === bc.ALPHA;
		var data = this._imageData.data;
		for (var y = 0, h = this.canvas.height; y &lt; h; y++) {
			for (var x = 0, w = this.canvas.width; x &lt; w; x++) {
				var noises;
				if (stitch) {
					noises = NoiseGenerator.getStitchNoises(x, y, w, h, baseX, baseY, numOctaves, fractalNoise, channels, grayScale, offsets);
				} else {
					noises = NoiseGenerator.getNoises(x, y, baseX, baseY, numOctaves, fractalNoise, channels, grayScale, offsets);
				}
				var r = ((w * y) + x) * 4;
				var g = r + 1;
				var b = r + 2;
				var a = r + 3;
				if (grayScale) {
					data[r] = data[g] = data[b] = noises[0] * 256;
				} else {
					data[r] = (chR) ? noises[0] * 256 : 0;
					data[g] = (chG) ? noises[1] * 256 : 0;
					data[b] = (chB) ? noises[2] * 256 : 0;
				}
				data[a] = (chA) ? noises[3] * 256 : 255;
			}
		}
		this.updateContext();
	};

	var NoiseGenerator = (function() {
		var PERSISTENCE = 0.5;
		var A = 1103515245;
		var B = 12345;
		var M = 2147483647;
		var seed = 1;
		var interpolate;
		function NoiseGenerator () {
		}
		NoiseGenerator.setProperties = function(s, type) {
			if (s !== 0) {
				seed = s % 0xffffff;
			}
			if (type === &quot;cos&quot;) {
				interpolate = cosineInterpolate;
			} else {
				interpolate = linearInterpolate;
			}
		};
		NoiseGenerator.getStitchNoises = function(x, y, w, h, baseX, baseY, numOctaves, fractalNoise, channels, grayScale, offsets) {
			var xw = x + w;
			var yh = y + h;
			var n11 = getNoises(x, y, baseX, baseY, numOctaves, fractalNoise, channels, grayScale, offsets);
			var n12 = getNoises(xw, y, baseX, baseY, numOctaves, fractalNoise, channels, grayScale, offsets);
			var n21 = getNoises(x, yh, baseX, baseY, numOctaves, fractalNoise, channels, grayScale, offsets);
			var n22 = getNoises(xw, yh, baseX, baseY, numOctaves, fractalNoise, channels, grayScale, offsets);
			var ratioX = x / w;
			var ratioY = y / h;
			var iRatioX = 1 - ratioX;
			var iRatioY = 1 - ratioY;
			var noises = [0, 0, 0, 0];
			if (grayScale || channels[0]) {
				noises[0] = n11[0] * ratioX * ratioY + n12[0] * iRatioX * ratioY + n21[0] * ratioX * iRatioY + n22[0] * iRatioX * iRatioY;
			}
			if (!grayScale &amp;&amp; channels[1]) {
				noises[1] = n11[1] * ratioX * ratioY + n12[1] * iRatioX * ratioY + n21[1] * ratioX * iRatioY + n22[1] * iRatioX * iRatioY;
			}
			if (!grayScale &amp;&amp; channels[2]) {
				noises[2] = n11[2] * ratioX * ratioY + n12[2] * iRatioX * ratioY + n21[2] * ratioX * iRatioY + n22[2] * iRatioX * iRatioY;
			}
			if (channels[3]) {
				noises[3] = n11[3] * ratioX * ratioY + n12[3] * iRatioX * ratioY + n21[3] * ratioX * iRatioY + n22[3] * iRatioX * iRatioY;
			}
			return noises;
		};
		function getNoises(x, y, baseX, baseY, numOctaves, fractalNoise, channels, grayScale, offsets) {
			var chR = channels[0];
			var chG = channels[1];
			var chB = channels[2];
			var chA = channels[3];
			var noises = [0, 0, 0, 0];
			var buffers = [];
			for (var i = 0; i &lt; numOctaves; i++) {
				var pow = i + 1;
				var freq = Math.pow(2, pow);
				var amp = Math.pow(PERSISTENCE, pow);
				var ox, oy;
				if (offsets[i]) {
					ox = offsets[i].x;
					oy = offsets[i].y;
				} else {
					ox = oy = 0;
				}
				var tx = (x + ox) / baseX * freq;
				var ty = (y + oy) / baseY * freq;
				if (grayScale) {
					buffers[0] = createNoise(tx, ty, 0);
				} else {
					if (chR) buffers[0] = createNoise(tx, ty, 0);
					if (chG) buffers[1] = createNoise(tx, ty, 1);
					if (chB) buffers[2] = createNoise(tx, ty, 2);
				}
				if (chA) buffers[3] = createNoise(tx, ty, 3);
				for (var j = 0, m = 4; j &lt; m; j++) {
					var v = buffers[j];
					if (v === undefined) {
						continue;
					}
					if (fractalNoise) {
						v = v * 0.6 + 0.2;
					} else {
						v = v * v;
					}
					noises[j] += v * amp;
				}
			}
			return noises;
		}
		NoiseGenerator.getNoises = getNoises;
		function createNoise(x, y, c) {
			var ix1 = x &gt;&gt; 0;
			var iy1 = y &gt;&gt; 0;
			var fx = x - ix1;
			var fy = y - iy1;
			var ix2 = ix1 + 1;
			var iy2 = iy1 + 1;
			var n11 = noise(ix1, iy1, c);
			var n12 = noise(ix2, iy1, c);
			var n21 = noise(ix1, iy2, c);
			var n22 = noise(ix2, iy2, c);
			var n1 = interpolate(n11, n12, fx);
			var n2 = interpolate(n21, n22, fx);
			return interpolate(n1, n2, fy);
		}
		function linearInterpolate(a, b, x) {
			return a * (1 - x) + b * x;
		}
		function cosineInterpolate(a, b, x) {
			var ft = x * Math.PI;
			var f = (1 - Math.cos(ft)) * 0.5;
			return a * (1 - f) + b * f;
		}
		function noise(x, y, c) {
			var r = (seed + x) * ((y + c) ^ B);
			r = ((r &lt;&lt; 13) ^ r) &amp; 0xffffffff;
			return ((A * r + B) &amp; M) / (M + 1);
		}
		return NoiseGenerator;
	}());

	/**
	* 現在のBitmapDataからソースオブジェクトへのピクセルディゾルブを実行します。
	* @method pixelDissolve
	* @param source {BitmapData | DisplayObject | Stage | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} ソースとなるオブジェクトを指定します。
	* @param sourceRect {Rectangle} ソースオブジェクトの範囲を示すRectangleです。
	* @param destPoint {Point} ディゾルブ先の左上座標を示すPointです。
	* @param [buffer=null] {Array} 連続したピクセルディゾルブを実行したい場合は、pixelDissolve()の戻り値のbuffer配列を指定します。
	* @param [numPixels=0] {uint} 1回の処理で置き換えるピクセル数です。デフォルト値は、sourceRect.width * souceRect.height / 30 です。
	* @param [fillColor=0] {uint} ソースオブジェクトが現在のBitmapDataの場合に使用されるカラー値を0xAARRGGBB形式の16進数値で指定します。
	* @return {Array} buffer配列を返します。この戻り値の配列を第4引数に指定することで連続したピクセルディゾルブを実行できます。ピクセルディゾルブが終了した際には数値 0 を返します。
	* @example
	* &lt;pre&gt;&lt;code&gt;function tickHandler(evt) {
  if (_buffer === 0) {
    return;
  }
  var sourceRect = new createjs.Rectangle(0, 0, _source.width, _source.height);
  var destPoint = new createjs.Point(sourceRect.x, sourceRect.y);
  var numPixels = 600;
  var fillColor = null
  _buffer = _bmd01.pixelDissolve(_source, sourceRect, destPoint, _buffer, numPixels, fillColor);
  _stage.update();
}&lt;/code&gt;&lt;/pre&gt;
	**/
	p.pixelDissolve = function(source, sourceRect, destPoint, buffer, numPixels, fillColor) {
		var w = this.canvas.width;
		var h = this.canvas.height;
		var sx = sourceRect.x &gt;&gt; 0;
		var sy = sourceRect.y &gt;&gt; 0;
		var sw = sourceRect.width &gt;&gt; 0;
		var sh = sourceRect.height &gt;&gt; 0;
		var dx = destPoint.x &gt;&gt; 0;
		var dy = destPoint.y &gt;&gt; 0;
		numPixels = numPixels || sw * sh / 30 &gt;&gt; 0;
		fillColor = fillColor || 0;
		var compare = this === source;
		var red, green, blue, alpha;
		if (compare) {
			red = fillColor &gt;&gt; 16 &amp; 0xFF;
			green = fillColor &gt;&gt; 8 &amp; 0xFF;
			blue = fillColor &amp; 0xFF;
			alpha = fillColor &gt;&gt; 24 &amp; 0xFF;
		}
		var sContext = getSourceContext(source, sx + sw, sy + sh);
		var sImgData = sContext.getImageData(sx, sy, sw, sh);
		var sData = sImgData.data;
		if (this._contextChanged) this.updateImageData();
		var tData = this._imageData.data;
		if (!buffer) {
			buffer = [];
			for (var i = 0, l = sw * sh; i &lt; l; i++) {
				buffer[i] = i;
			}
		}
		while (0 &lt; numPixels) {
			var random = Math.random() * (buffer.length - 1) &gt;&gt; 0;
			var bi = buffer.splice(random, 1)[0];
			var bx = bi % sw;
			var by = bi / sw &gt;&gt; 0;
			var tx = bx + dx;
			var ty = by + dy;
			if (tx &lt; 0 || ty &lt; 0 || w &lt;= tx || h &lt;= ty) {
				continue;
			}
			var ti = ((w * ty) + tx) * 4;
			if (compare) {
				tData[ti] = red;
				tData[++ti] = green;
				tData[++ti] = blue;
				tData[++ti] = alpha;
			} else {
				var si = bi * 4;
				tData[ti] = sData[si];
				tData[++ti] = sData[++si];
				tData[++ti] = sData[++si];
				tData[++ti] = sData[++si];
			}
			if (buffer.length === 0) {
				this.updateContext();
				return 0;
			}
			numPixels--;
		}
		this.updateContext();
		return buffer;
	};

	/**
	* 指定されたピクセル量だけイメージをスクロールします。スクロール領域外のエッジ領域は変わらずにそのままになります。
	* @method scroll
	* @param x {int} x軸方向のスクロール量です。
	* @param y {int} y軸方向のスクロール量です。
	**/
	p.scroll = function(x, y) {
		var ctx = this.context;
		if (this._contextChanged) this.updateImageData();
		ctx.putImageData(this._imageData, x &gt;&gt; 0, y &gt;&gt; 0);
		this._contextChanged = true;
	};

	/**
	* 指定された座標のピクセルに新しいカラー値を設定します。アルファチャンネルの値は現在の値が保たれます。setPixel()の実行結果を実際にBitmapDataに反映させるにはupdateContext()を実行する必要があります。
	* @method setPixel
	* @param x {uint} カラー値を設定するx座標です。
	* @param y {uint} カラー値を設定するy座標です。
	* @param color {uint} 指定したピクセルに設定するカラー値です。0xRRGGBB形式の16進数値のみ使用できます。
	* @example
	* &lt;pre&gt;&lt;code&gt;bmd.setPixel(x, y, 0x0099FF);&lt;/code&gt;&lt;/pre&gt;
	**/
	p.setPixel = function(x, y, color) {
		x = x &gt;&gt; 0;
		y = y &gt;&gt; 0;
		if (this._contextChanged) this.updateImageData();
		var imgData = this._imageData;
		var w = imgData.width;
		var h = imgData.height;
		if (w &lt;= x || h &lt;= y) {
			return;
		}
		var d = imgData.data;
		var i = ((w * y) + x) * 4;
		d[i] = color &gt;&gt; 16 &amp; 0xFF;
		d[++i] = color &gt;&gt; 8 &amp; 0xFF;
		d[++i] = color &amp; 0xFF;
	};

	/**
	* 指定された座標のピクセルにアルファチャンネルを含めた新しいカラー値を設定します。setPixel32()の実行結果を実際にBitmapDataに反映させるにはupdateContext()を実行する必要があります。
	* @method setPixel32
	* @param x {uint} カラー値を設定するx座標です。
	* @param y {uint} カラー値を設定するy座標です。
	* @param color {uint} 指定したピクセルに設定するカラー値です。0xAARRGGBB形式の16進数値のみ使用できます。
	**/
	p.setPixel32 = function(x, y, color) {
		x = x &gt;&gt; 0;
		y = y &gt;&gt; 0;
		if (this._contextChanged) this.updateImageData();
		var imgData = this._imageData;
		var w = imgData.width;
		var h = imgData.height;
		if (w &lt;= x || h &lt;= y) {
			return;
		}
		var d = imgData.data;
		var i = ((w * y) + x) * 4;
		d[i] = color &gt;&gt; 16 &amp; 0xFF;
		d[++i] = color &gt;&gt; 8 &amp; 0xFF;
		d[++i] = color &amp; 0xFF;
		d[++i] = color &gt;&gt; 24 &amp; 0xFF;
	};

	/**
	* 指定された範囲のピクセルを指定された配列のデータで差し替えます。
	* @method setPixels
	* @param rect {Rectangle} ピクセルデータを差し替える範囲を示すRectangleです。
	* @param inputArray {Array} 差し替えるピクセルデータを配列で指定します。ピクセルデータの並びは、R, G, B, Aの順番にする必要があります。
	**/
	p.setPixels = function(rect, inputArray) {
		var ctx = this.context;
		var imgData = ctx.createImageData(rect.width &gt;&gt; 0, rect.height &gt;&gt; 0);
		var data = imgData.data;
		for (var i = 0, l = data.length; i &lt; l; i++) {
			data[i] = inputArray[i];
		}
		ctx.putImageData(imgData, rect.x &gt;&gt; 0, rect.y &gt;&gt; 0);
		this._contextChanged = true;
	};

	/**
	* 指定されたしきい値でBitmapDataのピクセル値をテストし、その合否によってピクセルに新たなカラー値をセットします。
	* @method threshold
	* @param source {BitmapData | DisplayObject | Stage | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} ソースとなるオブジェクトを指定します。
	* @param sourceRect {Rectangle} ソースオブジェクトの範囲を示すRectangleです。
	* @param destPoint {Point} ピクセルの置き換え先の左上座標を示すPointです。
	* @param operation {String} ピクセルのテストに使う比較演算子を文字列で指定します。指定することができる値は、&quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;&gt;&quot;, &quot;&gt;=&quot;, &quot;==&quot;, &quot;!=&quot;です。
	* @param threshold {uint} しきい値となるカラー値を指定します。0xAARRGGBB形式の16進数値のみ使用できます。
	* @param [color=0] {uint} テストに合格した際にセットされる新しいカラー値を指定します。0xAARRGGBB形式の16進数値のみ使用できます。
	* @param [mask=0] {uint} 範囲を設定するマスク値を指定します。0xAARRGGBB形式の16進数値のみ使用できます。
	* @param [copySource=false] {Boolean} 比較結果がfalseの場合にソースオブジェクトのピクセルを現在のBitmapDataにコピーするかをBool値で指定します。
	* @example
	* &lt;pre&gt;&lt;code&gt;_bmd01 = new createjs.BitmapData(_image01);
var source = _bmd01;
var halfW = _bmd01.width &gt;&gt; 1;
var sourceRect = new createjs.Rectangle(halfW, 0, halfW, _bmd01.height);
var destPoint = new createjs.Point(sourceRect.x, sourceRect.y);
var operation = &amp;quot;&amp;lt;&amp;quot;;
var threshold = 0xFFEE0000;
var color = 0x00000000;
var mask = 0xFFFF0000;
var copySource = false;
_bmd01.threshold(source, sourceRect, destPoint, operation, threshold, color, mask, copySource);&lt;/code&gt;&lt;/pre&gt;
	**/
	p.threshold = function(source, sourceRect, destPoint, operation, threshold, color, mask, copySource) {
		var sx = sourceRect.x &gt;&gt; 0;
		var sy = sourceRect.y &gt;&gt; 0;
		var sw = sourceRect.width &gt;&gt; 0;
		var sh = sourceRect.height &gt;&gt; 0;
		var dx = destPoint.x &gt;&gt; 0;
		var dy = destPoint.y &gt;&gt; 0;
		var thresholdMethod = getThresholdMethod(operation);
		color = color || 0;
		var red = color &gt;&gt; 16 &amp; 0xFF;
		var green = color &gt;&gt; 8 &amp; 0xFF;
		var blue = color &amp; 0xFF;
		var alpha = color &gt;&gt; 24 &amp; 0xFF;
		if (mask === undefined) mask = 0xFFFFFFFF;
		var sContext = getSourceContext(source, sx + sw, sy + sh);
		var sImgData = sContext.getImageData(sx, sy, sw, sh);
		var sData = sImgData.data;
		var dContext = this.context;
		var dImgData = dContext.getImageData(dx, dy, sw, sh);
		var dData = dImgData.data;
		for (var i = 0, l = dData.length; i &lt; l; i += 4) {
			var r = i;
			var g = i + 1;
			var b = i + 2;
			var a = i + 3;
			var pixelValue = (sData[a] &lt;&lt; 24 | sData[r] &lt;&lt; 16 | sData[g] &lt;&lt; 8 | sData[b]) &gt;&gt;&gt; 0;
			if (thresholdMethod(pixelValue &amp; mask, threshold &amp; mask)) {
				dData[r] = red;
				dData[g] = green;
				dData[b] = blue;
				dData[a] = alpha;
			} else if (copySource) {
				dData[r] = sData[r];
				dData[g] = sData[g];
				dData[b] = sData[b];
				dData[a] = sData[a];
			}
		}
		dContext.putImageData(dImgData, dx, dy);
		this._contextChanged = true;
	};

	function getThresholdMethod(operation) {
		switch (operation) {
			case &quot;&lt;&quot; :
				return function(pixelValue, threshold) {
					return pixelValue &lt; threshold;
				};
			case &quot;&lt;=&quot; :
				return function(pixelValue, threshold) {
					return pixelValue &lt;= threshold;
				};
			case &quot;&gt;&quot; :
				return function(pixelValue, threshold) {
					return pixelValue &gt; threshold;
				};
			case &quot;&gt;=&quot; :
				return function(pixelValue, threshold) {
					return pixelValue &gt;= threshold;
				};
			case &quot;==&quot; :
				return function(pixelValue, threshold) {
					return pixelValue == threshold;
				};
			case &quot;!=&quot; :
				return function(pixelValue, threshold) {
					return pixelValue != threshold;
				};
		}
	}

	/**
	* BitmapDataの文字列表現を返します。nameプロパティの値が使用されます。
	* @method toString
	* @return {String} BitmapDataの文字列表現です。
	**/
	p.toString = function() {
		return &quot;[BitmapData (name=&quot; + this.name + &quot;)]&quot;;
	};

	/**
	* 内部に保持しているimageDataの内容でcontextを更新します。setPixel(), setPixel32()の処理を行った後は、このメソッドを実行する必要があります。updateContext()を実行することでsetPixel(), setPixel32()で行った処理がBitmapDataに反映されます。
	* @method updateContext
	**/
	p.updateContext = function() {
		this.context.putImageData(this._imageData, 0, 0);
	};

	/**
	* 内部に保持しているimageDataを最新の状態に更新します。contextを直接操作した場合やgetBitmapData()で取得したcacheをupdateCache()した場合には、このメソッドを実行する必要があります。
	* @method updateImageData
	**/
	p.updateImageData = function() {
		this._imageData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
		this._contextChanged = false;
	};

	function createCanvas(width, height) {
		var c = document.createElement(&quot;canvas&quot;);
		c.width = width;
		c.height = height;
		return c;
	}

	function getSourceContext(source, width, height) {
		var ctx;
		if (source instanceof BitmapData) {
			ctx = source.context;
		} else if (source instanceof HTMLCanvasElement) {
			ctx = source.getContext(&quot;2d&quot;);
		} else if (source instanceof createjs.Stage) {
			ctx = source.canvas.getContext(&quot;2d&quot;);
		} else if (source instanceof createjs.DisplayObject) {
			if (!!source.cacheCanvas) {
				ctx = source.cacheCanvas.getContext(&quot;2d&quot;);
			} else {
				throw new Error(&quot;The source must be called DisplayObject.cache().&quot;);
			}
		} else if (source instanceof HTMLImageElement || source instanceof HTMLVideoElement) {
			var cvs = createCanvas(width, height);
			ctx = cvs.getContext(&quot;2d&quot;);
			ctx.drawImage(source, 0, 0);
		}
		return ctx;
	}

	/**
	* BitmapDataChannelクラスは、赤、緑、青、アルファのいずれのチャンネルを使用するかを示す際に使用できる定数値を保持しています。メソッドを呼び出すとき、OR論理演算子を使ってBitmapDataChannel定数を結合することにより、複数のカラーチャンネルを同時に指定することができます。
	* @static
	* @class BitmapDataChannel
	**/
	var BitmapDataChannel = {
		/**
		* アルファチャンネルを表す定数です。
		* @static
		* @property ALPHA
		* @type uint
		* @default 8
		**/
		ALPHA : 8,

		/**
		* 青チャンネルを表す定数です。
		* @static
		* @property BLUE
		* @type uint
		* @default 4
		**/
		BLUE : 4,

		/**
		* 緑チャンネルを表す定数です。
		* @static
		* @property GREEN
		* @type uint
		* @default 2
		**/
		GREEN : 2,

		/**
		* 赤チャンネルを表す定数です。
		* @static
		* @property RED
		* @type uint
		* @default 1
		**/
		RED : 1,

		getChannelIndex : function(channel) {
			switch (channel) {
				case BitmapDataChannel.RED :
					return 0;
				case BitmapDataChannel.GREEN :
					return 1;
				case BitmapDataChannel.BLUE :
					return 2;
				case BitmapDataChannel.ALPHA :
					return 3;
			}
		}
	};

	/**
	* ColorTransformクラスは、BitmapDataクラスのカラー値を調整する際に使用することができます。R, G, B, Aの各チャンネルで乗数値（Multiplier）とオフセット値（Offset）を保持します。ColorTransformオブジェクトを適用する際に各チャンネルに設定される値の算出方法は下記の通りです。&lt;br&gt;新しい値 = (古い値 * Multiplier) + Offset
	* @class ColorTransform
	* @constructor
	* @param [redMultiplier=1] {Number} 赤チャンネルの乗数値です。
	* @param [greenMultiplier=1] {Number} 緑チャンネルの乗数値です。
	* @param [blueMultiplier=1] {Number} 青チャンネルの乗数値です。
	* @param [alphaMultiplier=1] {Number} アルファチャンネルの乗数値です。
	* @param [redOffset=0] {Number} 赤チャンネルのオフセット値です。
	* @param [greenOffset=0] {Number} 緑チャンネルのオフセット値です。
	* @param [blueOffset=0] {Number} 青チャンネルのオフセット値です。
	* @param [alphaOffset=0] {Number} アルファチャンネルのオフセット値です。
	**/
	var ColorTransform = (function() {
		function ColorTransform(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
			if (redMultiplier !== undefined) this.redMultiplier = redMultiplier;
			if (greenMultiplier !== undefined) this.greenMultiplier = greenMultiplier;
			if (blueMultiplier !== undefined) this.blueMultiplier = blueMultiplier;
			if (alphaMultiplier !== undefined) this.alphaMultiplier = alphaMultiplier;
			if (redOffset !== undefined) this.redOffset = redOffset;
			if (greenOffset !== undefined) this.greenOffset = greenOffset;
			if (blueOffset !== undefined) this.blueOffset = blueOffset;
			if (alphaOffset !== undefined) this.alphaOffset = alphaOffset;
		}

		var p = ColorTransform.prototype = {
			/**
			* ColortransformオブジェクトのRGBカラー値を返します。このプロパティに値を設定する際には、0xRRGGBB形式の16進数値を使用して下さい。設定された値は、R, G, Bのoffset値として設定され、同時に3つのカラー乗数値 (redMultiplier, greenMultiplier, blueMultiplier) が0に設定されます。アルファチャンネルの乗数値とオフセット値は変更しません。
			* @property color
			* @type uint
			**/
			get color() {
				return (this.redOffset &lt;&lt; 16 | this.greenOffset &lt;&lt; 8 | this.blueOffset) &gt;&gt;&gt; 0;
			},
			set color(value) {
				this.redMultiplier = this.greenMultiplier = this.blueMultiplier = 0;
				this.redOffset = value &gt;&gt; 16 &amp; 0xFF;
				this.greenOffset = value &gt;&gt; 8 &amp; 0xFF;
				this.blueOffset = value &amp; 0xFF;
			}
		};

		p.constructor = ColorTransform;

		/**
		* 赤チャンネル値に乗算する数値です。
		* @property redMultiplier
		* @type Number
		* @default 1
		**/
		p.redMultiplier = 1;

		/**
		* 緑チャンネル値に乗算する数値です。
		* @property greenMultiplier
		* @type Number
		* @default 1
		**/
		p.greenMultiplier = 1;

		/**
		* 青チャンネル値に乗算する数値です。
		* @property blueMultiplier
		* @type Number
		* @default 1
		**/
		p.blueMultiplier = 1;

		/**
		* アルファチャンネル値に乗算する数値です。
		* @property alphaMultiplier
		* @type Number
		* @default 1
		**/
		p.alphaMultiplier = 1;

		/**
		* 赤チャンネル値にredMultiplier値を乗算した後に加算する数値です。数値の範囲は -255～255です。
		* @property redOffset
		* @type Number
		* @default 0
		**/
		p.redOffset = 0;

		/**
		* 緑チャンネル値にgreenMultiplier値を乗算した後に加算する数値です。数値の範囲は -255～255です。
		* @property greenOffset
		* @type Number
		* @default 0
		**/
		p.greenOffset = 0;

		/**
		* 青チャンネル値にblueMultiplier値を乗算した後に加算する数値です。数値の範囲は -255～255です。
		* @property blueOffset
		* @type Number
		* @default 0
		**/
		p.blueOffset = 0;

		/**
		* アルファチャンネル値にalphaMultiplier値を乗算した後に加算する数値です。数値の範囲は -255～255です。
		* @property alphaOffset
		* @type Number
		* @default 0
		**/
		p.alphaOffset = 0;

		/**
		* 現在のColorTransformのクローンを作成します。
		* @method clone
		* @return {ColorTransform} 現在のColorTransformのクローンです。
		**/
		p.clone = function() {
			var ctf = Object.create(ColorTransform.prototype);
			if (this.hasOwnProperty(&quot;redMultiplier&quot;)) ctf.redMultiplier = this.redMultiplier;
			if (this.hasOwnProperty(&quot;greenMultiplier&quot;)) ctf.greenMultiplier = this.greenMultiplier;
			if (this.hasOwnProperty(&quot;blueMultiplier&quot;)) ctf.blueMultiplier = this.blueMultiplier;
			if (this.hasOwnProperty(&quot;alphaMultiplier&quot;)) ctf.alphaMultiplier = this.alphaMultiplier;
			if (this.hasOwnProperty(&quot;redOffset&quot;)) ctf.redOffset = this.redOffset;
			if (this.hasOwnProperty(&quot;greenOffset&quot;)) ctf.redOffset = this.redOffset;
			if (this.hasOwnProperty(&quot;blueOffset&quot;)) ctf.redOffset = this.redOffset;
			if (this.hasOwnProperty(&quot;alphaOffset&quot;)) ctf.redOffset = this.redOffset;
			return ctf;
		};

		/**
		* 引数のColorTransformと現在のColorTransformを連結します。
		* @method concat
		* @param second {ColorTransform} 現在のColorTransformオブジェクトと結合するColorTransformオブジェクトです。
		**/
		p.concat = function(second) {
			this.redOffset += this.redMultiplier * second.redOffset;
			this.greenOffset += this.greenMultiplier * second.greenOffset;
			this.blueOffset += this.blueMultiplier * second.blueOffset;
			this.alphaOffset += this.alphaMultiplier * second.alphaOffset;
			this.redMultiplier *= second.redMultiplier;
			this.greenMultiplier *= second.greenMultiplier;
			this.blueMultiplier *= second.blueMultiplier;
			this.alphaMultiplier *= second.alphaMultiplier;
		};

		/**
		* ColorTransformのすべてのプロパティを列挙した文字列表現を返します。
		* @method toString
		* @return {String} ColorTransformの文字列表現です。
		**/
		p.toString = function() {
			return &quot;[ColorTransform (redMultiplier=&quot; + this.redMultiplier + &quot;, greenMultiplier=&quot; + this.greenMultiplier + &quot;, blueMultiplier=&quot; + this.blueMultiplier + &quot;, alphaMultiplier=&quot; + this.alphaMultiplier + &quot;, redOffset=&quot; + this.redOffset + &quot;, greenOffset=&quot; + this.greenOffset + &quot;, blueOffset=&quot; + this.blueOffset + &quot;, alphaOffset=&quot; + this.alphaOffset + &quot;)]&quot;;
		};

		return ColorTransform;
	}());

	createjs.BitmapData = BitmapData;
	createjs.BitmapDataChannel = BitmapDataChannel;
	createjs.ColorTransform = ColorTransform;
}(window));
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
